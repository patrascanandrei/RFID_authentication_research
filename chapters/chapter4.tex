\chapter{Case study}
\definecolor{mygray}{gray}{0.75}
\definecolor{softred}{RGB}{255, 162, 162}

\section{A protocol attack}

    For the authentication proposed in \cite{BOM}, the tag stores in it's permanent memory the values: \textit{$A, B, p, S, Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$}.
    The global temporary memory will hold the value $N_t$
    used to authenticate the reader. It is generated at step 2 and held until step 10.

    % aici schema pentru interactiunea dintre tag si reader
    \begin{adjustwidth}{-60pt}{}
    \procedureblock[colspace=-0.5cm]{The tag-reader side protocol: Tag memory usage}{
    \textbf{Reader} \< \< \textbf{Tag} \\[-1ex]
    \textit{\footnotesize $A, B, p, S, N_r$} \< \< \textit{\footnotesize \colorbox{mygray}{$A, B, p, S, N_t$}} \\[-2ex]
    \textit{\footnotesize $Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$} \< \< \textit{\footnotesize \colorbox{mygray}{$Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$}} \\[-1.5ex]
    % \\
    \<\sendmessageright{top=\text{ \scriptsize 1.Query}} \< \\[-4ex]
    % \\
    \< \< \text{ \scriptsize 2.Generates \colorbox{olive}{$N_t$}} \\[-1ex]
    \< \< \text{ \scriptsize E($N_t||S$, A, p)} \\[-4ex]
    % \\
    \< \sendmessageleft{top=\text{ \scriptsize 3.E($N_t||S$, A, p)}} \< \\[-4ex]
    % \\
    \text{ \scriptsize 4.D(E($N_t||S$, A, p), B, p)} \< \< \\[-1ex]
    \text{ \scriptsize Generates $N_r$} \< \< \\[-1ex]
    \text{ \scriptsize E($N_r||S$, A, p)} \< \< \\[-1ex]
    % \\
    \text{ \scriptsize ...} \< \< \\[-1ex]
    % \\
    \text{ \scriptsize 8.D(E($N_r||S_d||S_p||S_c$, A, p), B, p)} \< \< \\[-1ex]
    \text{ \scriptsize E($N_t||S_d||S_p||S_c$, A, p)} \< \< \\[-4ex]
    % \\
    \<\sendmessageright{top = \text{ \scriptsize 9.E($N_t||S_d||S_p||S_c$, A, p)}}\<\\[-4ex]
    % \\
    \< \< \text{ \scriptsize 10.D(E($N_t||S_d||S_p||S_c$, A, p), B, p)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_d, Z_{DBLTKM}$)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_p, Z_{SUEO}$)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_c, Z_{AM}$)} \\[-1ex]
    \< \< \text{ \scriptsize E($N_t+1||ID$,$A_{new}$,q)} \\[-4ex]
    % \\
    \< \sendmessageleft{top=\text{ \scriptsize 11.E($N_t+1||ID$,$A_{new}$,q)}} \< \\[-4ex]
    }
    \end{adjustwidth}

    The adversary can interact with the protocol the following way:

    1. Adversary waits for a legitimate tag to respond to a reader query(step 3 of the protocol): E($N_t||S$,A,p).
    This can be achieved by also sending a query to the tag, compeling it to compute a nonce and sending E($N_t||S$,A,p).
    
    2. Adversary intercepts the response of the reader(step 9 of the protocol)to the tag: E($N_t||S_d||S_p||S_c$,A,p)
    
    3. Having the access to the tag, the adversary corrupts the tag and gets it's internal state. By doing that the adversary now knows $A, B, p, S, Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$ and the nonce $N_t$.
    
    4. Adversary decrypts E($N_t||S_d||S_p||S_c$,A,p) using the values B and p. Now the adversary has access to $S_d, S_p, S_c$ and computes the values $A_{new}$ and q.
    
    5. Using the newly obtained $A_{new}$ and q, adversary increments $N_t$, appends ID(found in the tag's memory when the corruption occured) and encrypts.
    
    6. Adversary sends the message to the reader whom can not descern that the tag has been tampered with.

    % aici schema pentru atacul de mai sus

    \begin{adjustwidth}{-60pt}{}
    \procedureblock[colspace=-0.5cm]{The tag-reader side protocol: Corrupt attack}{
    \textbf{Reader} \< \< \textbf{Tag} \\[-1ex]
    \textit{\footnotesize $A, B, p, S, N_r$} \< \< \textit{\footnotesize $A, B, p, S, N_t$} \\[-2ex]
    \textit{\footnotesize $Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$} \< \< \textit{\footnotesize $Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$} \\[-1.5ex]
    % \\
    \<\sendmessageright{top=\text{ \scriptsize \colorbox{softred}{$A$ sends query}}} \< \\[-4ex]
    % \\
    \< \< \text{ \scriptsize 2.Generates $N_t$} \\[-1ex]
    \< \< \text{ \scriptsize E($N_t||S$, A, p)} \\[-4ex]
    % \\
    \< \sendmessageleft{top=\text{ \scriptsize 3.E($N_t||S$, A, p)}} \< \\[-4ex]
    % \\
    \text{ \scriptsize 4.D(E($N_t||S$, A, p), B, p)} \< \< \\[-1ex]
    \text{ \scriptsize Generates $N_r$} \< \< \\[-1ex]
    \text{ \scriptsize E($N_r||S$, A, p)} \< \< \\[-1ex]
    % \\
    \text{ \scriptsize ...} \< \< \\[-1ex]
    % \\
    \text{ \scriptsize 8.D(E($N_r||S_d||S_p||S_c$, A, p), B, p)} \< \< \\[-1ex]
    \text{ \scriptsize E($N_t||S_d||S_p||S_c$, A, p)} \< \< \\[-4ex]
    % \\
    \<\sendmessageright{top = \text{ \scriptsize \colorbox{softred}{9.E($N_t||S_d||S_p||S_c$,A,p)}}, bottom = \text{\scriptsize \colorbox{softred}{Intercepted by $A$}}}\<\\[-4ex]
    % \\
    \< \< \text{ \scriptsize \colorbox{softred}{$A$ corrupts the tag, gets B, p and $S$}} \\[-1ex]
    \< \< \text{ \scriptsize \colorbox{softred}{$A$ can decrypt and use the tag}} \\[-1ex]
    % \\
    \< \< \text{ \scriptsize 10.D(E($N_t||S_d||S_p||S_c$, A, p), B, p)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_d, Z_{DBLTKM}$)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_p, Z_{SUEO}$)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_c, Z_{AM}$)} \\[-1ex]
    \< \< \text{ \scriptsize E($N_t+1||ID$,$A_{new}$,q)} \\[-4ex]
    % \\
    \< \sendmessageleft{top=\text{ \scriptsize 11.E($N_t+1||ID$,$A_{new}$,q)}} \< \\[-4ex]
    }
    \end{adjustwidth}

\section{Scheme security}
\begin{table}[H]
    \centering
    \caption{The security properties claimed by \cite{BOM}}
    \begin{tabular}{| c | c |}
        \hline
        Protocol & Claimed \\
        \hline
        Mutual authentication & Yes \\
        Location tracking & Yes \\
        DoS & Yes \\
        Impersonation attack & Yes  \\
        Man-in-the-middle attack & Yes  \\
        Replay attack & Yes  \\
        De-synchronization & Yes  \\
        Forward secrecy & Yes \\
        \hline
    \end{tabular}
\end{table}

    However many of the security claims do not hold in the context of tag corruption. An important note is that an adversary can corrupt
    a tag during the execution of the protocol, being it earlier or later in its computation.

    In the case of \textbf{mutual authentication}, an adversary can use the Corrupt() oracle to obtain secret $S$. By calling the CreateTag()
    oracle and using value $S$ illegitimate tags can be authenticated by a reader. Thus tag authentication is bypassed.
    This way of thwarting authentication is also the base for \textbf{impersonation attacks}.
    
    In the case of \textbf{location tracking} an adversary can corrupt a tag and infer relations or straight out obtain secret value $S$, meaning
    they can link it with a particular location. Strong adversaries can corrupt the tags and release them back. By sending a query(step 1
    of the protocol) and breaking reader authentication the adversary can further track the tag in case it was moved.

    A \textbf{DoS attack} consists in sending large amounts of data to a system in order to cause it to malfunction. The original protocol
    stops its execution as soon as a party fails to authenticate another, in an effort to prevent such an attack. However if the adversary 
    has access to sensitive data from tags then a DoS attack is more plausible than initially thought.

    The adversary can also use the sensitive information from a tag to implement a \textbf{man-in-the-middle attack}, for example the 
    interaction described in section 4.1.

\section{Use of BAN logic and assuptions}
    Burrows, Abadi and Needham developed a logic that can be used for analysing authentication protocols. The BAN logic makes it possible
    to formalise cryptographic protocols into structures usable in proofs. The basis of the logic is the belief of one party in the truth
    of a formula. 

    It should be noted that BAN logic has limitations. It is used for reasoning for cryptographic protocols however an analysis using this
    logic does not necessarily mean that no attacks are possible. BAN logic yields good proofs of correctness based on a set of assuptions.

    \newcommand{\believes}{\mid\equiv}
    \newcommand{\receives}{\triangleleft}
    \newcommand{\sends}{\mid\sim}
    \newcommand{\controls}{\Rightarrow}
    \newcommand{\fresh}[1]{\#(#1)}
    \newcommand{\encrypt}[2]{\{#1\}_{#2}}
    \newcommand{\sharesecret}[1]{\xleftrightarrow{#1}}

    \begin{table}[H]
    \centering
    \caption{BAN logic notations}
    \begin{tabular}{| c | c |}
        \hline
        Notations & Meaning \\
        \hline
        $P \believes X$ & P believes X \\
        $P \receives X$ & P receives X \\
        $P \sends X$ & P sends X \\
        $P \controls X$ & P has juristiction over X \\
        $ \fresh{X} $ & X is fresh \\
        $ \encrypt{X}{k} $ & X is encrypted by the secret key k \\
        $ P \sharesecret{k} Q $ & P and Q have a shared secret k \\
        \hline
    \end{tabular}
    \end{table}

    Some BAN logic rules are formed, one of them being R1 (Message-meaning rule): 
    
    \begin{center}
        $ \frac{P \believes Q \sharesecret{k} P, P \receives \encrypt{X}{k}}{P \believes Q \receives X} $
    \end{center}
    
    This rule states: if P believes that Q and P have a shared secret (a key for this rule) and P receives encrypted X by secret key k, then
    P can believe Q has sent X. This rule is based on good reasoning, that the key k is only usable for sending information between P and Q 
    and is known only by P and Q.

    However taking into consideration tag corruption and the possibility of a strong adversary that can obtain the state of a tag and then
    release it back into the environment makes the second part of R1 false. A rule that does not cover such an adversary means a BAN
    logic demonstration that cannot correctly verify security properties.
    
    Tag corruption affects two of the assuptions for the BAN logic demonstration for the protocol \cite{BOM}:

    \begin{center}
        $ A3: R \believes T \controls \encrypt{N_t||S}{}\ and\ A12: T \believes R \controls \{N_t||S_d||S_p||S_c\} $
    \end{center}

    For assuption A3, a reader cannot trust a tag while a strong adversary can bypass tag authentication. In section 3.2 it is shown 
    that a scheme cannot
    achieve narrow-forward privacy and reader authentication. This means that narrow-forward adversary can make a tag authenticate
    a false reader and so assuption A12 cannot be used also. If the state disclosure covers only the persistent state then the same is
    true but for a narrow-strong adversary.

\section{Achievable classes of privacy}

    Clearly access to the Corrupt oracle has major consequences on RFID schemes. Following the impossibility results from section 3, 
    depending on the tags used, these classes of privacy can be achieved:

    \begin{table}[H]
    \centering
    \caption{The security properties achievable for various tags}
    \begin{tabular}{| c | c |}
        \hline
        Class of tag & achievable privacy \\
        \hline
        With temporary state disclosure & weak \& narrow-weak privacy\\
        Without temporary state disclosure & destructive \& narrow-destructive privacy\\
        Resetable & no privacy \\
        Stateless & narrow-destructive \& forward privacy \\
        \hline
    \end{tabular}
    \end{table}

    These results lead to an extended discusion about security for a given RFID scheme. The \cite{BOM} scheme achieves (mutual)
    authentication between tags and reader and between reader and server. For the former, the reader authenticates the tag by
    receiving the secret value $S$ and querying it into its internal database to check its legitimacy. Reader authentication is
    achieved by decrypting the message at step 9 and receiving back value $N_t$. Only the reader should be able to decrypt 
    E($N_t||S$,A,p) (step 3) and obtain $N_t$ and be able to send it back, thus proving authenticity.
    
    % aici schema pentru mutual authentication
    \begin{adjustwidth}{-60pt}{}
    \procedureblock[colspace=-0.5cm]{The tag-reader side protocol: mutual authentication}{
    \textbf{Reader} \< \< \textbf{Tag} \\[-1ex]
    \textit{\footnotesize $A, B, p, S, N_r$} \< \< \textit{\footnotesize $A, B, p, $\colorbox{olive}{$S$}$, N_t$} \\[-2ex]
    \textit{\footnotesize $Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$} \< \< \textit{\footnotesize $Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$} \\[-1.5ex]
    % \\
    \<\sendmessageright{top=\text{ \scriptsize 1.Query}} \< \\[-4ex]
    % \\
    \< \< \text{ \scriptsize 2.Generates \colorbox{mygray}{$N_t$}} \\[-1ex]
    \< \< \text{ \scriptsize E($N_t||S$, A, p)} \\[-4ex]
    % \\
    \< \sendmessageleft{top=\text{ \scriptsize 3.E($N_t||S$, A, p)}} \< \\[-4ex]
    % \\
    \text{ \scriptsize 4.D(E(\colorbox{mygray}{$N_t$}$||$\colorbox{olive}{$S$}, A, p), B, p)} \< \< \\[-1ex]
    \text{ \scriptsize Generates $N_r$} \< \< \\[-1ex]
    \text{ \scriptsize E($N_r||S$, A, p)} \< \< \\[-1ex]
    % \\
    \text{ \scriptsize ...} \< \< \\[-1ex]
    % \\
    \text{ \scriptsize 8.D(E($N_r||S_d||S_p||S_c$, A, p), B, p)} \< \< \\[-1ex]
    \text{ \scriptsize E(\colorbox{mygray}{$N_t$}$||S_d||S_p||S_c$, A, p)} \< \< \\[-4ex]
    % \\
    \<\sendmessageright{top = \text{ \scriptsize 9.E($N_t||S_d||S_p||S_c$, A, p)}}\<\\[-4ex]
    % \\
    \< \< \text{ \scriptsize 10.D(E(\colorbox{mygray}{$N_t$}$||S_d||S_p||S_c$, A, p), B, p)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_d, Z_{DBLTKM}$)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_p, Z_{SUEO}$)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_c, Z_{AM}$)} \\[-1ex]
    \< \< \text{ \scriptsize E($N_t+1||ID$,$A_{new}$,q)} \\[-4ex]
    % \\
    \< \sendmessageleft{top=\text{ \scriptsize 11.E($N_t+1||ID$,$A_{new}$,q)}} \< \\[-4ex]
    }
    \end{adjustwidth}
    
    For tag-reader mutual authentication recall:

    \textbf{Theorem 1}: \textit{There is no RFID system in Vaudenay's model that achieves both reader authentication and narrow-forward privacy 
    under temporary state disclosure.}

    This means that for the scheme presented the achievable privacy is weak or narrow-weak for the case in which the adversary has no
    access to the Result oracle. This result is based on the presumption that temporary state disclosure includes the temporary
    memory of the tag and additionally the persistent state.

    For the case of disclosure of only the permanent state of the tag the impossibility results of theorem 2 state:

    \textbf{Theorem 2}: \textit{There is no RFID system in Vaudenay's model that achieves both reader authentication and narrow-strong privacy 
    under permanent state disclosure.}

    Thus under the presumption that the Corrupt oracle yields only the permanent state, the scheme can achieve at most destructive or
    narrow-destructive privacy.

    Resetable tags and the ability of the adversary to change the state to its initial values lead to the impossibility of narrow-weak
    privacy. Thus the use of such tags does not guarantee even the weakest class of privacy.

    Stateless tags do not change their internal memory and the use of them can yield at best narrow-destructive or forward privacy.
