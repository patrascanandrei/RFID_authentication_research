\chapter{Case study}
\definecolor{mygray}{gray}{0.75}
\definecolor{softred}{RGB}{255, 162, 162}

\section{A tag memory usage}

    For the authentication proposed in \cite{BOM}, the tag stores in it's permanent memory the values: \textit{$A, B, p, S, Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$}.
    The global temporary memory will hold the value $N_t$
    used to authenticate the reader. It is generated at step 2 and held until step 10.

    % aici schema pentru interactiunea dintre tag si reader
    \begin{adjustwidth}{-60pt}{}
    \procedureblock[colspace=-0.5cm]{The tag-reader side protocol: Tag memory usage}{
    \textbf{Reader} \< \< \textbf{Tag} \\[-1ex]
    \textit{\footnotesize $A, B, p, S, N_r$} \< \< \textit{\footnotesize \colorbox{mygray}{$A, B, p, S, N_t$}} \\[-2ex]
    \textit{\footnotesize $Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$} \< \< \textit{\footnotesize \colorbox{mygray}{$Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$}} \\[-1.5ex]
    % \\
    \<\sendmessageright{top=\text{ \scriptsize 1.Query}} \< \\[-4ex]
    % \\
    \< \< \text{ \scriptsize 2.Generates \colorbox{olive}{$N_t$}} \\[-1ex]
    \< \< \text{ \scriptsize E($N_t||S$, A, p)} \\[-4ex]
    % \\
    \< \sendmessageleft{top=\text{ \scriptsize 3.E($N_t||S$, A, p)}} \< \\[-4ex]
    % \\
    \text{ \scriptsize 4.D(E($N_t||S$, A, p), B, p)} \< \< \\[-1ex]
    \text{ \scriptsize Generates $N_r$} \< \< \\[-1ex]
    \text{ \scriptsize E($N_r||S$, A, p)} \< \< \\[-1ex]
    % \\
    \text{ \scriptsize ...} \< \< \\[-1ex]
    % \\
    \text{ \scriptsize 8.D(E($N_r||S_d||S_p||S_c$, A, p), B, p)} \< \< \\[-1ex]
    \text{ \scriptsize E($N_t||S_d||S_p||S_c$, A, p)} \< \< \\[-4ex]
    % \\
    \<\sendmessageright{top = \text{ \scriptsize 9.E($N_t||S_d||S_p||S_c$, A, p)}}\<\\[-4ex]
    % \\
    \< \< \text{ \scriptsize 10.D(E($N_t||S_d||S_p||S_c$, A, p), B, p)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_d, Z_{DBLTKM}$)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_p, Z_{SUEO}$)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_c, Z_{AM}$)} \\[-1ex]
    \< \< \text{ \scriptsize E($N_t+1||ID$,$A_{new}$,q)} \\[-4ex]
    % \\
    \< \sendmessageleft{top=\text{ \scriptsize 11.E($N_t+1||ID$,$A_{new}$,q)}} \< \\[-4ex]
    }
    \end{adjustwidth}

\section{Temporary state disclosure attack}

    As it was presented in section 3.2, a narrow-forward adversary can interact with a scheme the following way, given the assuption that
    the Corrupt() oracle yields the persistent and the temporary memory is true:

    1. Adversary waits for a legitimate tag to respond to a reader query (step 3 of the protocol): E($N_t||S$,A,p).
    This can be achieved by also sending a query to the tag, compeling it to compute a nonce and sending E($N_t||S$,A,p).

    2. Before the tag receives the message from the reader with an encrypted nonce $N_t$ the adversary corrupts the tag, obtaining
    its internal state. By doing that the adversary now knows $A, B, p, S, Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$ and the nonce $N_t$.
    
    3. Adversary impersonates the reader and sends an encrypted message. This message will seem legitimate to the tag because it would
    contain the nonce $N_t$ and be encrypted by $A$ and $p$.

    4. The tag receives the message, decrypts it, receives the nonce and authenticates the illegitimate reader.

    % aici schema pentru atacul de mai sus

    \begin{adjustwidth}{-30pt}{}
    \procedureblock[colspace=-1cm]{The tag-reader side protocol: Temporary state disclosure attack}{
    \textbf{Reader} \< \< \textbf{Adversary} \< \< \textbf{Tag} \\[-1ex]
    \textit{\footnotesize $A, B, p, S, N_r$} \< \< \< \< \textit{\footnotesize $A, B, p, S, N_t$} \\[-2ex]
    \textit{\footnotesize $Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$} \< \< \< \< \textit{\footnotesize $Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$} \\[-1.5ex]
    % \\
    \< \< \< \sendmessageright{top=\text{ \scriptsize \colorbox{softred}{$A$ sends query}}} \< \\[-2ex]
    % \\
    \< \< \< \<\text{ \scriptsize 2.Generates $N_t$} \\[-1ex]
    \< \< \< \<\text{ \scriptsize E($N_t||S$, A, p)} \\[-3ex]
    % \\
    \< \< \< \sendmessageleft{top=\text{ \scriptsize 3.E($N_t||S$, A, p)}} \< \\[-2ex]
    \< \< \text{ \scriptsize $\mathcal{A}$ forwards the message} \< \< \\[-2ex]
    \< \sendmessageleft{top=\text{ \scriptsize 3.E($N_t||S$, A, p)}} \< \\[-4ex]
    % \\
    \text{ \scriptsize 4.D(E($N_t||S$, A, p), B, p)} \< \< \\[-1ex]
    \text{ \scriptsize Generates $N_r$} \< \< \\[-1ex]
    \text{ \scriptsize E($N_r||S$, A, p)} \< \< \\[-1ex]
    % \\
    \text{ \scriptsize ...} \< \< \< \< \text{ \scriptsize \colorbox{softred}{Tag is corrupted by $\mathcal{A}$}}\\[-1ex]
    \< \< \< \sendmessageleft{top=\text{\scriptsize $A, B, p, S, N_t, Z_{AM}$}, bottom = \text{\scriptsize $Z_{DBLTKM}, Z_{SUEO}$}} \< \\[-2ex]
    % \\
    \text{ \scriptsize 8.D(E($N_r||S_d||S_p||S_c$, A, p), B, p)} \< \< \text{ \scriptsize $\mathcal{A}$ encripts $N_t$ and 3 arbitrary}\\[-1ex]
    \text{ \scriptsize E($N_t||S_d||S_p||S_c$, A, p)}\< \< \text{ \scriptsize parameters using $A$ and $p$}\\[-1ex]
    % \\
    \<\sendmessageright{top = \text{ \scriptsize \colorbox{softred}{9.E($N_t||S_d||S_p||S_c$,A,p)}}, bottom = \text{\scriptsize \colorbox{softred}{Stopped by $A$}}}\< \< \sendmessageright{top = \text{ \scriptsize \colorbox{softred}{E($N_t||S_0||S_1||S_2$,A,p)}}, bottom = \text{\scriptsize \colorbox{softred}{Created by $A$}}}\\[-3ex]
    % \\
    \< \< \< \< \text{ \scriptsize 10.D(E($N_t||S_0||S_1||S_2$, A, p), B, p)} \\[-1ex]
    \< \< \< \< \text{ \scriptsize Stored $N_t$ = received $N_t$,} \\[-1ex]
    \< \< \< \< \text{ \scriptsize the reader is authenticated} \\[-1ex]
    % \\
    }
    \end{adjustwidth}

    This attack is the equivalent of the one presented in Figure 3.2, adapted for the block-order-modulus protocol. 

    This is how an adversary bypasses reader authentication, applied to a practical protocol. Making a tag
    accept an illegitimate reader leads to the tag to disclose sensitive information. This data can be linked to the tag, breaching privacy.
    However for this case, privacy is already broken by the ability of the adversary to corrupt the tag, thus obtaining the ID of the tag.
    The attack emphasizes that if a protocol achieves reader authentication then that scheme cannot also achieve anything higher than weak
    privacy because of the Corrupt() oracle.

\section{Permanent state disclosure attack}

    In the following is presented how an narrow-strong adversary can interact with the scheme. It is assumed that 
    corruption of the tags yields only the persistent state. This mirrors the results in section 3.3.
    
    The interaction consists of:

    1. The adversary corrupts the tag before it generates the temporary variables, obtaining the persistent state: 
    $A$, $B$, $p$, $S$, $Z_{DBLTKM}$, $Z_{SUEO}$, $Z_{AM}$.

    2. The adversary takes a guess at the number of protocol steps to be computed.

    3. Adversary sends a query, prompting the tag to start an instance of the protocol.

    4. Using the variables obtained from the Corrupt() oracle the adversary intercepts the response from the reader, is able to decrypt 
    the message and get nonce $N_t$. 

    5. The adversary impersonates the reader by encrypting the nonce and 3 arbitrary variables. The tag will receive the nonce, compare it
    to its own and authenticate the illegitimate reader.

    This attack is the equivalent of the one presented in Figure 3.3, adapted for the block-order-modulus protocol. 
    % aici schema pentru atacul de mai sus

    \begin{adjustwidth}{-30pt}{}
    \procedureblock[colspace=-1cm]{The tag-reader side protocol: Permanent state disclosure attack}{
    \textbf{Reader} \< \< \textbf{Adversary} \< \< \textbf{Tag} \\[-1ex]
    \textit{\footnotesize $A, B, p, S, N_r$} \< \< \< \< \textit{\footnotesize $A, B, p, S, N_t$} \\[-2ex]
    \textit{\footnotesize $Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$} \< \< \< \< \textit{\footnotesize $Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$} \\[-1.5ex]
    % \\
    \< \< \< \< \text{ \scriptsize \colorbox{softred}{Tag is corrupted by $\mathcal{A}$}}\\[-1ex]
    \< \< \< \sendmessageleft{top=\text{\scriptsize $A, B, p, S, Z_{AM}$}, bottom = \text{\scriptsize $Z_{DBLTKM}, Z_{SUEO}$}} \< \\[-2ex]
    \< \< \text{ \scriptsize $\mathcal{A}$ gets the persistent state} \\[-1ex]
    % \\
    \< \< \< \sendmessageright{top=\text{ \scriptsize \colorbox{softred}{$A$ sends query}}} \< \\[-2ex]
    % \\
    \< \< \< \<\text{ \scriptsize 2.Generates $N_t$} \\[-1ex]
    \< \< \< \<\text{ \scriptsize E($N_t||S$, A, p)} \\[-3ex]
    % \\
    \< \< \< \sendmessageleft{top=\text{ \scriptsize 3.E($N_t||S$, A, p)}} \< \\[-2ex]
    \< \< \text{ \scriptsize $\mathcal{A}$ forwards the message} \< \< \\[-2ex]
    \< \sendmessageleft{top=\text{ \scriptsize 3.E($N_t||S$, A, p)}} \< \\[-4ex]
    % \\
    \text{ \scriptsize 4.D(E($N_t||S$, A, p), B, p)} \< \< \\[-1ex]
    \text{ \scriptsize Generates $N_r$} \< \< \\[-1ex]
    \text{ \scriptsize E($N_r||S$, A, p)} \< \< \\[-1ex]
    % \\
    \text{ \scriptsize ...} \\[-1ex]
    % \\
    \text{ \scriptsize 8.D(E($N_r||S_d||S_p||S_c$, A, p), B, p)}\\[-1ex]
    \text{ \scriptsize E($N_t||S_d||S_p||S_c$, A, p)}\\[-1ex]
    % \\
    \<\sendmessageright{top = \text{ \scriptsize \colorbox{softred}{9.E($N_t||S_d||S_p||S_c$,A,p)}}, bottom = \text{\scriptsize \colorbox{softred}{Intercepted by $A$}}} \\[-3ex]
    % \\
    \< \< \text{ \scriptsize $\mathcal{A}$ decrypts, obtains $N_t$. It}\\[-1ex]
    \< \< \text{ \scriptsize and 3 arbitrary parameters are}\\[-1ex]
    \< \< \text{ \scriptsize encrypted using $A$ and $p$}\\[-2ex]
    % \\
    \< \< \< \sendmessageright{top = \text{ \scriptsize \colorbox{softred}{E($N_t||S_0||S_1||S_2$,A,p)}}, bottom = \text{\scriptsize \colorbox{softred}{Created by $A$}}}\\[-3ex]
    % \\
    \< \< \< \< \text{ \scriptsize 10.D(E($N_t||S_0||S_1||S_2$, A, p), B, p)} \\[-1ex]
    \< \< \< \< \text{ \scriptsize Stored $N_t$ = received $N_t$,} \\[-1ex]
    \< \< \< \< \text{ \scriptsize the reader is authenticated} \\[-1ex]
    % \\
    }
    \end{adjustwidth}

    The same conclusions drawn in the previous section are viable for this scheme as well. Due to the assuption of permanent state disclosure the 
    previous attack had to be adapted such that the nonce used for authentication is obtained differently.

\section{Scheme security}
\begin{table}[H]
    \centering
    \caption{The security properties claimed by \cite{BOM}}
    \begin{tabular}{| c | c |}
        \hline
        Protocol & Claimed \\
        \hline
        Mutual authentication & Yes \\
        Location tracking & Yes \\
        DoS & Yes \\
        Impersonation attack & Yes  \\
        Man-in-the-middle attack & Yes  \\
        Replay attack & Yes  \\
        De-synchronization & Yes  \\
        Forward secrecy & Yes \\
        \hline
    \end{tabular}
\end{table}

    However many of the security claims do not hold in the context of tag corruption. An important note is that an adversary can corrupt
    a tag during the execution of the protocol, being it earlier or later in its computation.

    In the case of \textbf{mutual authentication}, an adversary can use the Corrupt() oracle to obtain secret $S$. By calling the CreateTag()
    oracle and using value $S$ illegitimate tags can be authenticated by a reader. Thus tag authentication is bypassed.
    This way of thwarting authentication is also the base for \textbf{impersonation attacks}.
    
    In the case of \textbf{location tracking} an adversary can corrupt a tag and infer relations or straight out obtain secret value $S$, meaning
    they can link it with a particular location. Strong adversaries can corrupt the tags and release them back. By sending a query(step 1
    of the protocol) and breaking reader authentication the adversary can further track the tag in case it was moved.

    A \textbf{DoS attack} consists in sending large amounts of data to a system in order to cause it to malfunction. The original protocol
    stops its execution as soon as a party fails to authenticate another, in an effort to prevent such an attack. However if the adversary 
    has access to sensitive data from tags then a DoS attack is more plausible than initially thought.

    The adversary can also use the sensitive information from a tag to implement a \textbf{man-in-the-middle attack}, for example the 
    interaction described in section 4.1.

\section{Use of BAN logic and assuptions}
    Burrows, Abadi and Needham developed a logic that can be used for analysing authentication protocols. The BAN logic makes it possible
    to formalise cryptographic protocols into structures usable in proofs. The basis of the logic is the belief of one party in the truth
    of a formula. 

    It should be noted that BAN logic has limitations. It is used for reasoning for cryptographic protocols however an analysis using this
    logic does not necessarily mean that no attacks are possible. BAN logic yields good proofs of correctness based on a set of assuptions.

    \newcommand{\believes}{\mid\equiv}
    \newcommand{\receives}{\triangleleft}
    \newcommand{\sends}{\mid\sim}
    \newcommand{\controls}{\Rightarrow}
    \newcommand{\fresh}[1]{\#(#1)}
    \newcommand{\encrypt}[2]{\{#1\}_{#2}}
    \newcommand{\sharesecret}[1]{\xleftrightarrow{#1}}

    \begin{table}[H]
    \centering
    \caption{BAN logic notations}
    \begin{tabular}{| c | c |}
        \hline
        Notations & Meaning \\
        \hline
        $P \believes X$ & P believes X \\
        $P \receives X$ & P receives X \\
        $P \sends X$ & P sends X \\
        $P \controls X$ & P has juristiction over X \\
        $ \fresh{X} $ & X is fresh \\
        $ \encrypt{X}{k} $ & X is encrypted by the secret key k \\
        $ P \sharesecret{k} Q $ & P and Q have a shared secret k \\
        \hline
    \end{tabular}
    \end{table}

    Some BAN logic rules are formed, one of them being R1 (Message-meaning rule): 
    
    \begin{center}
        $ \frac{P \believes Q \sharesecret{k} P, P \receives \encrypt{X}{k}}{P \believes Q \receives X} $
    \end{center}
    
    This rule states: if P believes that Q and P have a shared secret (a key for this rule) and P receives encrypted X by secret key k, then
    P can believe Q has sent X. This rule is based on good reasoning, that the key k is only usable for sending information between P and Q 
    and is known only by P and Q.

    However taking into consideration tag corruption and the possibility of a strong adversary that can obtain the state of a tag and then
    release it back into the environment makes the second part of R1 false. A rule that does not cover such an adversary means a BAN
    logic demonstration that cannot correctly verify security properties.
    
    Tag corruption affects two of the assuptions for the BAN logic demonstration for the protocol \cite{BOM}:

    \begin{center}
        $ A3: R \believes T \controls \encrypt{N_t||S}{}\ and\ A12: T \believes R \controls \{N_t||S_d||S_p||S_c\} $
    \end{center}

    For assuption A3, a reader cannot trust a tag while a strong adversary can bypass tag authentication. In section 3.2 it is shown 
    that a scheme cannot
    achieve narrow-forward privacy and reader authentication. This means that narrow-forward adversary can make a tag authenticate
    a false reader and so assuption A12 cannot be used also. If the state disclosure covers only the persistent state then the same is
    true but for a narrow-strong adversary.

\section{Achievable classes of privacy}

    Clearly access to the Corrupt oracle has major consequences on RFID schemes. Following the impossibility results from section 3, 
    depending on the tags used, these classes of privacy can be achieved:

    \begin{table}[H]
    \centering
    \caption{The security properties achievable for various tags}
    \begin{tabular}{| c | c |}
        \hline
        Class of tag & achievable privacy \\
        \hline
        With temporary state disclosure & weak \& narrow-weak privacy\\
        Without temporary state disclosure & destructive \& narrow-destructive privacy\\
        Resetable & no privacy \\
        Stateless & narrow-destructive \& forward privacy \\
        \hline
    \end{tabular}
    \end{table}

    These results lead to an extended discusion about security for a given RFID scheme. The \cite{BOM} scheme achieves (mutual)
    authentication between tags and reader and between reader and server. For the former, the reader authenticates the tag by
    receiving the secret value $S$ and querying it into its internal database to check its legitimacy. Reader authentication is
    achieved by decrypting the message at step 9 and receiving back value $N_t$. Only the reader should be able to decrypt 
    E($N_t||S$,A,p) (step 3) and obtain $N_t$ and be able to send it back, thus proving authenticity.
    
    % aici schema pentru mutual authentication
    \begin{adjustwidth}{-60pt}{}
    \procedureblock[colspace=-0.5cm]{The tag-reader side protocol: mutual authentication}{
    \textbf{Reader} \< \< \textbf{Tag} \\[-1ex]
    \textit{\footnotesize $A, B, p, S, N_r$} \< \< \textit{\footnotesize $A, B, p, $\colorbox{olive}{$S$}$, N_t$} \\[-2ex]
    \textit{\footnotesize $Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$} \< \< \textit{\footnotesize $Z_{DBLTKM}, Z_{SUEO}, Z_{AM}$} \\[-1.5ex]
    % \\
    \<\sendmessageright{top=\text{ \scriptsize 1.Query}} \< \\[-4ex]
    % \\
    \< \< \text{ \scriptsize 2.Generates \colorbox{mygray}{$N_t$}} \\[-1ex]
    \< \< \text{ \scriptsize E($N_t||S$, A, p)} \\[-4ex]
    % \\
    \< \sendmessageleft{top=\text{ \scriptsize 3.E($N_t||S$, A, p)}} \< \\[-4ex]
    % \\
    \text{ \scriptsize 4.D(E(\colorbox{mygray}{$N_t$}$||$\colorbox{olive}{$S$}, A, p), B, p)} \< \< \\[-1ex]
    \text{ \scriptsize Generates $N_r$} \< \< \\[-1ex]
    \text{ \scriptsize E($N_r||S$, A, p)} \< \< \\[-1ex]
    % \\
    \text{ \scriptsize ...} \< \< \\[-1ex]
    % \\
    \text{ \scriptsize 8.D(E($N_r||S_d||S_p||S_c$, A, p), B, p)} \< \< \\[-1ex]
    \text{ \scriptsize E(\colorbox{mygray}{$N_t$}$||S_d||S_p||S_c$, A, p)} \< \< \\[-4ex]
    % \\
    \<\sendmessageright{top = \text{ \scriptsize 9.E($N_t||S_d||S_p||S_c$, A, p)}}\<\\[-4ex]
    % \\
    \< \< \text{ \scriptsize 10.D(E(\colorbox{mygray}{$N_t$}$||S_d||S_p||S_c$, A, p), B, p)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_d, Z_{DBLTKM}$)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_p, Z_{SUEO}$)} \\[-1ex]
    \< \< \text{ \scriptsize Calculates mod($S_c, Z_{AM}$)} \\[-1ex]
    \< \< \text{ \scriptsize E($N_t+1||ID$,$A_{new}$,q)} \\[-4ex]
    % \\
    \< \sendmessageleft{top=\text{ \scriptsize 11.E($N_t+1||ID$,$A_{new}$,q)}} \< \\[-4ex]
    }
    \end{adjustwidth}
    
    For tag-reader mutual authentication recall:

    \textbf{Theorem 1}: \textit{There is no RFID system in Vaudenay's model that achieves both reader authentication and narrow-forward privacy 
    under temporary state disclosure.}

    This means that for the scheme presented the achievable privacy is weak or narrow-weak for the case in which the adversary has no
    access to the Result oracle. This result is based on the presumption that temporary state disclosure includes the temporary
    memory of the tag and additionally the persistent state.

    For the case of disclosure of only the permanent state of the tag the impossibility results of theorem 2 state:

    \textbf{Theorem 2}: \textit{There is no RFID system in Vaudenay's model that achieves both reader authentication and narrow-strong privacy 
    under permanent state disclosure.}

    Thus under the presumption that the Corrupt oracle yields only the permanent state, the scheme can achieve at most destructive or
    narrow-destructive privacy.

    Resetable tags and the ability of the adversary to change the state to its initial values lead to the impossibility of narrow-weak
    privacy. Thus the use of such tags does not guarantee even the weakest class of privacy.

    Stateless tags do not change their internal memory and the use of them can yield at best narrow-destructive or forward privacy.
